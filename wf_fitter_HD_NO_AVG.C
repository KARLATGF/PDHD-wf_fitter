// THIS CODE TAKES THE AVERAGED WAVEFORMS GENERATED BY THE AVERAGING ALGORITHM.
// AND APPLIES A SIMPLE FITTER MADE OF TWO
// ELECTRONICS RESPONSE FUNCTIONS.

// AVERAGING ALGORITHM Located at /average/pulse_average_HD.C

#include <TFile.h>
#include <TTree.h>
#include <TBranch.h>
#include <TH1D.h>
#include <TH2D.h>
#include <TF1.h>
#include <TH2.h>
#include <TH1.h>
#include <TLatex.h>
#include <TStyle.h>
#include <TPad.h>
#include <iostream>
#include <fstream>
#include <vector>
#include <array>
#include <TCanvas.h>
#include <TPad.h>
#include "TGraph.h"
#include <TGraphErrors.h>
#include <TSystem.h>
#include <math.h>
#include <TROOT.h>
#include <TAttLine.h>
#include <TLegend.h>
#include <TString.h>
#include <cmath> // For std::abs
#include "TFitResult.h"
#include <fstream>
#include <TFitResult.h>
#include <TFitResultPtr.h>
#include <limits>
#include "Math/MinimizerOptions.h"


#include "TPaveStats.h"
#include "TPaveLabel.h"

using std::cout;
using std::cin;
using std::endl;

std::vector<int> positivePeakBins;
std::vector<double> positivePeakValues;
std::vector<int> negativePeakStartBins;
std::vector<int> negativePeakEndBins;
std::vector<double> negativePeakStartValues;
std::vector<double> negativePeakEndValues;





Double_t ScaleX(Double_t x){
  Double_t v;
  v = (0.512 * x); // to scale ticks to microseconds
  return v;
}

void ScaleAxis(TAxis *a, Double_t (*Scale)(Double_t)){

    if (!a) return; // just a precaution
    if (a->GetXbins()->GetSize())
        {
            // an axis with variable bins
            // note: bins must remain in increasing order, hence the "Scale"
            // function must be strictly (monotonically) increasing
            TArrayD X(*(a->GetXbins()));
            for(Int_t i = 0; i < X.GetSize(); i++) X[i] = Scale(X[i]);
            a->Set((X.GetSize() - 1), X.GetArray()); // new Xbins
        }
    else
        {
            // an axis with fix bins
            // note: we modify Xmin and Xmax only, hence the "Scale" function
            // must be linear (and Xmax must remain greater than Xmin)
            a->Set( a->GetNbins(),
                    Scale(a->GetXmin()), // new Xmin
                    Scale(a->GetXmax()) ); // new Xmax
        }
    return;

    }

void ScaleXaxis(TH1 *h, Double_t (*Scale)(Double_t)){

    if (!h) return;
    ScaleAxis(h->GetXaxis(), Scale);
    return;

    }



void FindPeaks(TH1D* hist, double positiveThreshold, double negativeThreshold,
               std::vector<int>& positivePeakBins, std::vector<double>& positivePeakValues,
               std::vector<int>& negativePeakBins, std::vector<double>& negativePeakValues) {

    positivePeakBins.clear();
    positivePeakValues.clear();
    negativePeakBins.clear();
    negativePeakValues.clear();

    bool inPositivePeakRegion = false;
    bool foundPositivePeak = false;
    double maxNegativePeakValue = std::numeric_limits<double>::max();
    int maxNegativePeakBin = -1;
    bool inNegativePeak = false;


    for (int i = 1; i <= hist->GetNbinsX(); ++i) {

        double current = hist->GetBinContent(i);
        double next = i < hist->GetNbinsX() ? hist->GetBinContent(i + 1) : std::numeric_limits<double>::max();
        double prev = i > 1 ? hist->GetBinContent(i - 1) : std::numeric_limits<double>::max();

        // Positive peak detection
        if (!inPositivePeakRegion && current > positiveThreshold && current > prev && current > next) {
            positivePeakBins.push_back(i);
            positivePeakValues.push_back(current);
            inPositivePeakRegion = true;
            foundPositivePeak = true;
            // Reset for next negative peak
            maxNegativePeakValue = std::numeric_limits<double>::max();
            maxNegativePeakBin = -1;
        } else if (inPositivePeakRegion && current <= positiveThreshold) {
            inPositivePeakRegion = false;
        }


        // Negative peak tracking after a positive peak
        if (foundPositivePeak) {
            if (!inNegativePeak && current <= negativeThreshold) {
                // Entering a negative peak region
                inNegativePeak = true;
                maxNegativePeakValue = current;
                maxNegativePeakBin = i; // Provisionally, this might be updated
            } else if (inNegativePeak) {
                if (current < maxNegativePeakValue) {
                    // Found a new max negative value within the peak
                    maxNegativePeakValue = current;
                    maxNegativePeakBin = i;
                } else if (current == maxNegativePeakValue) {
                    // Extend the peak to the last bin with the same value
                    maxNegativePeakBin = i;
                } else if (current > maxNegativePeakValue || i == hist->GetNbinsX()) {
                    // Exiting the negative peak region or end of histogram
                    inNegativePeak = false;
                    negativePeakBins.push_back(maxNegativePeakBin);
                    negativePeakValues.push_back(maxNegativePeakValue);
                    foundPositivePeak = false; // Reset for the next sequence
                    // Prepare for the next negative peak
                    maxNegativePeakValue = std::numeric_limits<double>::max();
                    maxNegativePeakBin = -1;
                }
            }
        }
    }

    if (positivePeakBins.size()==0) { // If somehow positive peaks weren't found, just get te maximum one (?).

        cout << "WARNING: No positive peaks were found!" << endl;
        double max = hist->GetMaximum();
        double max_bin = hist->GetMaximumBin();

        positivePeakBins.push_back(max_bin);
        positivePeakValues.push_back(max);
    }


    // Print results
    std::cout << "Positive Peaks: \n";
    for (size_t i = 0; i < positivePeakBins.size(); ++i) {
        std::cout << "Bin: " << positivePeakBins[i] << ", Value: " << positivePeakValues[i] << "\n";
    }

    std::cout << "\nNegative Peaks:\n";
    for (size_t i = 0; i < negativePeakBins.size(); ++i) {
        std::cout << "Bin: " << negativePeakBins[i] << ", Value: " << negativePeakValues[i] << "\n";
    }

    std::cout << "****************************************\n";


} //END FUNCTION

/////////////////////////////////////////////////////////////////////////////////////////



// BASED ON THE NUMBER OF ENTRIES OF HISTOGRAM: Noisy = millions of entries. Probably not a correct assumption, but good enough for now.
bool isHistogramTooNoisy(TH1D* hist, double maxAllowedEntries){

    if(hist->GetEntries() >= maxAllowedEntries){
        return true;
    }else return false;

}


/////////////////////////////////////////////////////////////////////////////////////////

//  Dealing with noisy histograms:

bool FindPeaksWithNoiseCheck(TH1D* hist, double positiveThreshold, double negativeThreshold,
                             std::vector<int>& positivePeakBins, std::vector<double>& positivePeakValues,
                             std::vector<int>& negativePeakBins, std::vector<double>& negativePeakValues,
                             double maxAllowedEntries){
    // Check if the histogram is too noisy
    if (isHistogramTooNoisy(hist, maxAllowedEntries)) {
        std::cout << "Histogram is too noisy and will be skipped." << std::endl;
        return false; // Histogram was too noisy and was skipped
    }

    // Call the original FindPeaks function if the histogram is not too noisy
    FindPeaks(hist, positiveThreshold, negativeThreshold, positivePeakBins, positivePeakValues, negativePeakBins, negativePeakValues);

    return true; // Histogram was processed
}



///////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////DEFINING FIT FUNCTIONS/////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////


double gaussian(double *x, double *par){
    return (par[0]*TMath::Gaus(x[0], par[1], par[2]));
}


double response(double *x, double *par){
  Double_t t = x[0]-par[0];
  //Double_t t = par[0];
  Double_t A0 = par[1];
  Double_t tp = par[2];
  Double_t CT = 1./1.996;
  Double_t A = A0 * 2.7433/pow(tp*CT,4);
  Double_t p0 = 1.477/tp/CT;
  Double_t pr1 = 1.417/tp/CT;
  Double_t pr2 = 1.204/tp/CT;
  Double_t pi1 = 0.598/tp/CT;
  Double_t pi2 = 1.299/tp/CT;


  double k3 = par[3];
  double k4 = par[4];
  double k5 = par[5];
  double k6 = par[6];

  double value = A*((-(k3*k4) + pow(k4,2) + k3*k5 - k4*k5)/(exp(k4*t)*(k4 - k6)*(k4 - p0)*(pow(k4,2) + pow(pi1,2) - 2*k4*pr1 + pow(pr1,2))*(pow(k4,2) + pow(pi2,2) - 2*k4*pr2 + pow(pr2,2))) +
	     (-(k3*k5) + k3*k6 + k5*k6 - pow(k6,2))/(exp(k6*t)*(k4 - k6)*(k6 - p0)*(pow(k6,2) + pow(pi1,2) - 2*k6*pr1 + pow(pr1,2))*(pow(k6,2) + pow(pi2,2) - 2*k6*pr2 + pow(pr2,2))) +
	     (-(k3*k5) + k3*p0 + k5*p0 - pow(p0,2))/(exp(p0*t)*(k4 - p0)*(-k6 + p0)*(pow(p0,2) + pow(pi1,2) - 2*p0*pr1 + pow(pr1,2))*(pow(p0,2) + pow(pi2,2) - 2*p0*pr2 + pow(pr2,2))) +
     (pi1*((pow(pi1,2) + pow(pr1,2))*(2*k6*(pow(pi1,2) + pow(pr1,2))*(pr1 - pr2) + k6*p0*(-pow(pi1,2) + pow(pi2,2) - pow(pr1,2) + pow(pr2,2)) + (pow(pi1,2) + pow(pr1,2))*(pow(pi1,2) - pow(pi2,2) + (pr1 - pr2)*(2*p0 - 3*pr1 + pr2)) +
              k5*(2*pow(pi1,2)*(-2*pr1 + pr2) + p0*(pow(pi1,2) - pow(pi2,2) - 3*pow(pr1,2) + 4*pr1*pr2 - pow(pr2,2)) + 2*pr1*(pow(pi2,2) + 2*pow(pr1,2) - 3*pr1*pr2 + pow(pr2,2)) +
                 k6*(pow(pi1,2) - pow(pi2,2) + (pr1 - pr2)*(2*p0 - 3*pr1 + pr2)))) + k4*((pow(pi1,2) + pow(pr1,2))*(2*(pow(pi1,2) + pow(pr1,2))*(pr1 - pr2) + p0*(-pow(pi1,2) + pow(pi2,2) - pow(pr1,2) + pow(pr2,2))) +
              k5*(2*k6*(pow(pi1,2) + pow(pr1,2))*(pr1 - pr2) - k6*p0*(pow(pi1,2) - pow(pi2,2) + pow(pr1,2) - pow(pr2,2)) + (pow(pi1,2) + pow(pr1,2))*(pow(pi1,2) - pow(pi2,2) + (pr1 - pr2)*(2*p0 - 3*pr1 + pr2))) +
              k6*(-pow(pi1,4) + pow(pi1,2)*(pow(pi2,2) - 2*pow(pr1,2) + 2*p0*pr2 + pow(pr2,2)) + pr1*(pr1*(pow(pi2,2) - pow(pr1,2) + pow(pr2,2)) - 2*p0*(pow(pi2,2) - pr1*pr2 + pow(pr2,2))))) +
           k3*(-((pow(pi1,2) + pow(pr1,2))*(4*pow(pi1,2)*pr1 - 2*pow(pi2,2)*pr1 - 4*pow(pr1,3) - 2*pow(pi1,2)*pr2 + 6*pow(pr1,2)*pr2 - 2*pr1*pow(pr2,2) + p0*(-pow(pi1,2) + pow(pi2,2) + 3*pow(pr1,2) - 4*pr1*pr2 + pow(pr2,2)) +
                   k6*(-pow(pi1,2) + pow(pi2,2) - (pr1 - pr2)*(2*p0 - 3*pr1 + pr2)))) + k5*(-pow(pi1,4) + pow(pi1,2)*(pow(pi2,2) - 4*p0*pr1 + 10*pow(pr1,2) + 2*p0*pr2 - 8*pr1*pr2 + pow(pr2,2)) +
                 k6*(2*pow(pi1,2)*(-2*pr1 + pr2) + p0*(pow(pi1,2) - pow(pi2,2) - 3*pow(pr1,2) + 4*pr1*pr2 - pow(pr2,2)) + 2*pr1*(pow(pi2,2) + 2*pow(pr1,2) - 3*pr1*pr2 + pow(pr2,2))) +
                 pr1*(2*p0*(pow(pi2,2) + 2*pow(pr1,2) - 3*pr1*pr2 + pow(pr2,2)) - pr1*(3*pow(pi2,2) + 5*pow(pr1,2) - 8*pr1*pr2 + 3*pow(pr2,2)))) +
              k4*(2*k6*(pow(pi1,2) + pow(pr1,2))*(pr1 - pr2) + k6*p0*(-pow(pi1,2) + pow(pi2,2) - pow(pr1,2) + pow(pr2,2)) + (pow(pi1,2) + pow(pr1,2))*(pow(pi1,2) - pow(pi2,2) + (pr1 - pr2)*(2*p0 - 3*pr1 + pr2)) +
                 k5*(2*pow(pi1,2)*(-2*pr1 + pr2) + p0*(pow(pi1,2) - pow(pi2,2) - 3*pow(pr1,2) + 4*pr1*pr2 - pow(pr2,2)) + 2*pr1*(pow(pi2,2) + 2*pow(pr1,2) - 3*pr1*pr2 + pow(pr2,2)) +
                    k6*(pow(pi1,2) - pow(pi2,2) + (pr1 - pr2)*(2*p0 - 3*pr1 + pr2))))))*cos(pi1*t) -
        ((pow(pi1,2) + pow(pr1,2))*((pow(pi1,2) + pow(pr1,2))*(p0*(pow(pi1,2) - pow(pi2,2) - pow(pr1 - pr2,2)) + pr1*(pow(pi2,2) + pow(pr1 - pr2,2)) + pow(pi1,2)*(-3*pr1 + 2*pr2)) +
              k6*(pow(pi1,4) + (p0 - pr1)*pr1*(pow(pi2,2) + pow(pr1 - pr2,2)) - pow(pi1,2)*(pow(pi2,2) - p0*pr1 + 2*p0*pr2 - 2*pr1*pr2 + pow(pr2,2))) +
              k5*(-pow(pi1,4) + (p0 - pr1)*pr1*(pow(pi2,2) + pow(pr1 - pr2,2)) + pow(pi1,2)*(pow(pi2,2) - 3*p0*pr1 + 6*pow(pr1,2) + 2*p0*pr2 - 6*pr1*pr2 + pow(pr2,2)) +
                 k6*(p0*(pow(pi1,2) - pow(pi2,2) - pow(pr1 - pr2,2)) + pr1*(pow(pi2,2) + pow(pr1 - pr2,2)) + pow(pi1,2)*(-3*pr1 + 2*pr2)))) +
           k4*((pow(pi1,2) + pow(pr1,2))*(pow(pi1,4) + (p0 - pr1)*pr1*(pow(pi2,2) + pow(pr1 - pr2,2)) - pow(pi1,2)*(pow(pi2,2) - p0*pr1 + 2*p0*pr2 - 2*pr1*pr2 + pow(pr2,2))) +
              k5*((pow(pi1,2) + pow(pr1,2))*(p0*(pow(pi1,2) - pow(pi2,2) - pow(pr1 - pr2,2)) + pr1*(pow(pi2,2) + pow(pr1 - pr2,2)) + pow(pi1,2)*(-3*pr1 + 2*pr2)) +
                 k6*(pow(pi1,4) + (p0 - pr1)*pr1*(pow(pi2,2) + pow(pr1 - pr2,2)) - pow(pi1,2)*(pow(pi2,2) - p0*pr1 + 2*p0*pr2 - 2*pr1*pr2 + pow(pr2,2)))) +
              k6*((pow(pi1,2) + pow(pr1,2))*(pr1*(pow(pi2,2) + pow(pr1 - pr2,2)) + pow(pi1,2)*(pr1 - 2*pr2)) -
                 p0*(pow(pi1,4) + pow(pr1,2)*(pow(pi2,2) + pow(pr1 - pr2,2)) - pow(pi1,2)*(pow(pi2,2) - 2*pow(pr1,2) + 2*pr1*pr2 + pow(pr2,2))))) +
           k3*((pow(pi1,2) + pow(pr1,2))*(-pow(pi1,4) + (p0 - pr1)*pr1*(pow(pi2,2) + pow(pr1 - pr2,2)) + pow(pi1,2)*(pow(pi2,2) - 3*p0*pr1 + 6*pow(pr1,2) + 2*p0*pr2 - 6*pr1*pr2 + pow(pr2,2)) +
                 k6*(p0*(pow(pi1,2) - pow(pi2,2) - pow(pr1 - pr2,2)) + pr1*(pow(pi2,2) + pow(pr1 - pr2,2)) + pow(pi1,2)*(-3*pr1 + 2*pr2))) +
              k5*(5*pow(pi1,4)*pr1 - 3*pow(pi1,2)*pow(pi2,2)*pr1 - 10*pow(pi1,2)*pow(pr1,3) + pow(pi2,2)*pow(pr1,3) + pow(pr1,5) - 2*pow(pi1,4)*pr2 + 12*pow(pi1,2)*pow(pr1,2)*pr2 - 2*pow(pr1,4)*pr2 - 3*pow(pi1,2)*pr1*pow(pr2,2) +
                 pow(pr1,3)*pow(pr2,2) - p0*(pow(pi1,4) + pow(pr1,2)*(pow(pi2,2) + pow(pr1 - pr2,2)) - pow(pi1,2)*(pow(pi2,2) + 6*pow(pr1,2) - 6*pr1*pr2 + pow(pr2,2))) +
                 k6*(-pow(pi1,4) + (p0 - pr1)*pr1*(pow(pi2,2) + pow(pr1 - pr2,2)) + pow(pi1,2)*(pow(pi2,2) - 3*p0*pr1 + 6*pow(pr1,2) + 2*p0*pr2 - 6*pr1*pr2 + pow(pr2,2)))) +
              k4*((pow(pi1,2) + pow(pr1,2))*(p0*(pow(pi1,2) - pow(pi2,2) - pow(pr1 - pr2,2)) + pr1*(pow(pi2,2) + pow(pr1 - pr2,2)) + pow(pi1,2)*(-3*pr1 + 2*pr2)) +
                 k6*(pow(pi1,4) + (p0 - pr1)*pr1*(pow(pi2,2) + pow(pr1 - pr2,2)) - pow(pi1,2)*(pow(pi2,2) - p0*pr1 + 2*p0*pr2 - 2*pr1*pr2 + pow(pr2,2))) +
                 k5*(-pow(pi1,4) + (p0 - pr1)*pr1*(pow(pi2,2) + pow(pr1 - pr2,2)) + pow(pi1,2)*(pow(pi2,2) - 3*p0*pr1 + 6*pow(pr1,2) + 2*p0*pr2 - 6*pr1*pr2 + pow(pr2,2)) +
                    k6*(p0*(pow(pi1,2) - pow(pi2,2) - pow(pr1 - pr2,2)) + pr1*(pow(pi2,2) + pow(pr1 - pr2,2)) + pow(pi1,2)*(-3*pr1 + 2*pr2))))))*sin(pi1*t))/
	     (exp(pr1*t)*pi1*(pow(k4,2) + pow(pi1,2) - 2*k4*pr1 + pow(pr1,2))*(pow(k6,2) + pow(pi1,2) - 2*k6*pr1 + pow(pr1,2))*(pow(p0,2) + pow(pi1,2) - 2*p0*pr1 + pow(pr1,2))*
        (pow(pi1,4) - 2*pow(pi1,2)*(pow(pi2,2) - pow(pr1 - pr2,2)) + pow(pow(pi2,2) + pow(pr1 - pr2,2),2))) +
     (-(pi2*(k4*(-((pow(pi2,2) + pow(pr2,2))*(p0*(pow(pi1,2) - pow(pi2,2) + pow(pr1,2) - pow(pr2,2)) - 2*(pr1 - pr2)*(pow(pi2,2) + pow(pr2,2)))) +
                k5*((pow(pi1,2) - pow(pi2,2) + (2*p0 + pr1 - 3*pr2)*(pr1 - pr2))*(pow(pi2,2) + pow(pr2,2)) + 2*k6*(pr1 - pr2)*(pow(pi2,2) + pow(pr2,2)) + k6*p0*(-pow(pi1,2) + pow(pi2,2) - pow(pr1,2) + pow(pr2,2))) +
                k6*(pow(pi2,4) - pow(pi2,2)*(2*p0*pr1 + pow(pr1,2) - 2*pow(pr2,2)) - pow(pi1,2)*(pow(pi2,2) + pr2*(-2*p0 + pr2)) - (pr1 - pr2)*pr2*(-2*p0*pr1 + pr2*(pr1 + pr2)))) +
             (pow(pi2,2) + pow(pr2,2))*((pow(pi1,2) - pow(pi2,2) + (2*p0 + pr1 - 3*pr2)*(pr1 - pr2))*(pow(pi2,2) + pow(pr2,2)) + 2*k6*(pr1 - pr2)*(pow(pi2,2) + pow(pr2,2)) + k6*p0*(-pow(pi1,2) + pow(pi2,2) - pow(pr1,2) + pow(pr2,2)) +
                k5*(k6*(pow(pi1,2) - pow(pi2,2) + (2*p0 + pr1 - 3*pr2)*(pr1 - pr2)) + p0*(pow(pi1,2) - pow(pi2,2) + pow(pr1,2) - 4*pr1*pr2 + 3*pow(pr2,2)) -
                   2*(pow(pi2,2)*(pr1 - 2*pr2) + pr2*(pow(pi1,2) + pow(pr1,2) - 3*pr1*pr2 + 2*pow(pr2,2))))) +
             k3*((pow(pi2,2) + pow(pr2,2))*(k6*(pow(pi1,2) - pow(pi2,2) + (2*p0 + pr1 - 3*pr2)*(pr1 - pr2)) + p0*(pow(pi1,2) - pow(pi2,2) + pow(pr1,2) - 4*pr1*pr2 + 3*pow(pr2,2)) -
                   2*(pow(pi2,2)*(pr1 - 2*pr2) + pr2*(pow(pi1,2) + pow(pr1,2) - 3*pr1*pr2 + 2*pow(pr2,2)))) +
                k5*(pow(pi2,4) - 2*p0*pow(pi2,2)*pr1 - pow(pi2,2)*pow(pr1,2) + 4*p0*pow(pi2,2)*pr2 + 8*pow(pi2,2)*pr1*pr2 - 2*p0*pow(pr1,2)*pr2 - 10*pow(pi2,2)*pow(pr2,2) + 6*p0*pr1*pow(pr2,2) + 3*pow(pr1,2)*pow(pr2,2) -
                   4*p0*pow(pr2,3) - 8*pr1*pow(pr2,3) + 5*pow(pr2,4) - pow(pi1,2)*(pow(pi2,2) + (2*p0 - 3*pr2)*pr2) + k6*p0*(pow(pi1,2) - pow(pi2,2) + pow(pr1,2) - 4*pr1*pr2 + 3*pow(pr2,2)) -
                   2*k6*(pow(pi2,2)*(pr1 - 2*pr2) + pr2*(pow(pi1,2) + pow(pr1,2) - 3*pr1*pr2 + 2*pow(pr2,2)))) +
                k4*((pow(pi1,2) - pow(pi2,2) + (2*p0 + pr1 - 3*pr2)*(pr1 - pr2))*(pow(pi2,2) + pow(pr2,2)) + 2*k6*(pr1 - pr2)*(pow(pi2,2) + pow(pr2,2)) + k6*p0*(-pow(pi1,2) + pow(pi2,2) - pow(pr1,2) + pow(pr2,2)) +
                   k5*(k6*(pow(pi1,2) - pow(pi2,2) + (2*p0 + pr1 - 3*pr2)*(pr1 - pr2)) + p0*(pow(pi1,2) - pow(pi2,2) + pow(pr1,2) - 4*pr1*pr2 + 3*pow(pr2,2)) -
                      2*(pow(pi2,2)*(pr1 - 2*pr2) + pr2*(pow(pi1,2) + pow(pr1,2) - 3*pr1*pr2 + 2*pow(pr2,2)))))))*cos(pi2*t)) +
        ((pow(pi2,2) + pow(pr2,2))*((pow(pi2,2) + pow(pr2,2))*(p0*(pow(pi1,2) - pow(pi2,2) + pow(pr1 - pr2,2)) - (pow(pi1,2) + pow(pr1 - pr2,2))*pr2 + pow(pi2,2)*(-2*pr1 + 3*pr2)) +
              k6*(-pow(pi2,4) - (p0 - pr2)*pow(pr1 - pr2,2)*pr2 + pow(pi2,2)*(2*p0*pr1 + pow(pr1,2) - p0*pr2 - 2*pr1*pr2) + pow(pi1,2)*(pow(pi2,2) + pr2*(-p0 + pr2))) +
              k5*(-(pow(pi1,2)*pow(pi2,2)) + pow(pi2,4) - 2*p0*pow(pi2,2)*pr1 - pow(pi2,2)*pow(pr1,2) - p0*pow(pi1,2)*pr2 + 3*p0*pow(pi2,2)*pr2 + 6*pow(pi2,2)*pr1*pr2 - p0*pow(pr1,2)*pr2 + pow(pi1,2)*pow(pr2,2) -
                 6*pow(pi2,2)*pow(pr2,2) + 2*p0*pr1*pow(pr2,2) + pow(pr1,2)*pow(pr2,2) - p0*pow(pr2,3) - 2*pr1*pow(pr2,3) + pow(pr2,4) +
                 k6*(p0*(pow(pi1,2) - pow(pi2,2) + pow(pr1 - pr2,2)) - (pow(pi1,2) + pow(pr1 - pr2,2))*pr2 + pow(pi2,2)*(-2*pr1 + 3*pr2)))) +
           k4*(-(k6*(pow(pi2,2) + pow(pr2,2))*((pow(pi1,2) + pow(pr1 - pr2,2))*pr2 + pow(pi2,2)*(-2*pr1 + pr2))) +
              k6*p0*(pow(pi2,4) + pow(pr1 - pr2,2)*pow(pr2,2) - pow(pi2,2)*(pow(pr1,2) + 2*pr1*pr2 - 2*pow(pr2,2)) + pow(pi1,2)*(-pow(pi2,2) + pow(pr2,2))) +
              (pow(pi2,2) + pow(pr2,2))*(-pow(pi2,4) - (p0 - pr2)*pow(pr1 - pr2,2)*pr2 + pow(pi2,2)*(2*p0*pr1 + pow(pr1,2) - p0*pr2 - 2*pr1*pr2) + pow(pi1,2)*(pow(pi2,2) + pr2*(-p0 + pr2))) +
              k5*((pow(pi2,2) + pow(pr2,2))*(p0*(pow(pi1,2) - pow(pi2,2) + pow(pr1 - pr2,2)) - (pow(pi1,2) + pow(pr1 - pr2,2))*pr2 + pow(pi2,2)*(-2*pr1 + 3*pr2)) +
                 k6*(-pow(pi2,4) - (p0 - pr2)*pow(pr1 - pr2,2)*pr2 + pow(pi2,2)*(2*p0*pr1 + pow(pr1,2) - p0*pr2 - 2*pr1*pr2) + pow(pi1,2)*(pow(pi2,2) + pr2*(-p0 + pr2))))) +
           k3*((pow(pi2,2) + pow(pr2,2))*(-(pow(pi1,2)*pow(pi2,2)) + pow(pi2,4) - 2*p0*pow(pi2,2)*pr1 - pow(pi2,2)*pow(pr1,2) - p0*pow(pi1,2)*pr2 + 3*p0*pow(pi2,2)*pr2 + 6*pow(pi2,2)*pr1*pr2 - p0*pow(pr1,2)*pr2 +
                 pow(pi1,2)*pow(pr2,2) - 6*pow(pi2,2)*pow(pr2,2) + 2*p0*pr1*pow(pr2,2) + pow(pr1,2)*pow(pr2,2) - p0*pow(pr2,3) - 2*pr1*pow(pr2,3) + pow(pr2,4) +
                 k6*(p0*(pow(pi1,2) - pow(pi2,2) + pow(pr1 - pr2,2)) - (pow(pi1,2) + pow(pr1 - pr2,2))*pr2 + pow(pi2,2)*(-2*pr1 + 3*pr2))) -
              k5*(p0*pow(pi1,2)*pow(pi2,2) - p0*pow(pi2,4) - 2*pow(pi2,4)*pr1 + p0*pow(pi2,2)*pow(pr1,2) - 3*pow(pi1,2)*pow(pi2,2)*pr2 + 5*pow(pi2,4)*pr2 - 6*p0*pow(pi2,2)*pr1*pr2 - 3*pow(pi2,2)*pow(pr1,2)*pr2 -
                 p0*pow(pi1,2)*pow(pr2,2) + 6*p0*pow(pi2,2)*pow(pr2,2) + 12*pow(pi2,2)*pr1*pow(pr2,2) - p0*pow(pr1,2)*pow(pr2,2) + pow(pi1,2)*pow(pr2,3) - 10*pow(pi2,2)*pow(pr2,3) + 2*p0*pr1*pow(pr2,3) + pow(pr1,2)*pow(pr2,3) -
                 p0*pow(pr2,4) - 2*pr1*pow(pr2,4) + pow(pr2,5) + k6*(-pow(pi2,4) + (p0 - pr2)*pow(pr1 - pr2,2)*pr2 + pow(pi1,2)*(pow(pi2,2) + (p0 - pr2)*pr2) + pow(pi2,2)*(2*p0*pr1 + pow(pr1,2) - 3*p0*pr2 - 6*pr1*pr2 + 6*pow(pr2,2)))) +
              k4*((pow(pi2,2) + pow(pr2,2))*(p0*(pow(pi1,2) - pow(pi2,2) + pow(pr1 - pr2,2)) - (pow(pi1,2) + pow(pr1 - pr2,2))*pr2 + pow(pi2,2)*(-2*pr1 + 3*pr2)) +
                 k6*(-pow(pi2,4) - (p0 - pr2)*pow(pr1 - pr2,2)*pr2 + pow(pi2,2)*(2*p0*pr1 + pow(pr1,2) - p0*pr2 - 2*pr1*pr2) + pow(pi1,2)*(pow(pi2,2) + pr2*(-p0 + pr2))) +
                 k5*(-(pow(pi1,2)*pow(pi2,2)) + pow(pi2,4) - 2*p0*pow(pi2,2)*pr1 - pow(pi2,2)*pow(pr1,2) - p0*pow(pi1,2)*pr2 + 3*p0*pow(pi2,2)*pr2 + 6*pow(pi2,2)*pr1*pr2 - p0*pow(pr1,2)*pr2 + pow(pi1,2)*pow(pr2,2) -
                    6*pow(pi2,2)*pow(pr2,2) + 2*p0*pr1*pow(pr2,2) + pow(pr1,2)*pow(pr2,2) - p0*pow(pr2,3) - 2*pr1*pow(pr2,3) + pow(pr2,4) +
                    k6*(p0*(pow(pi1,2) - pow(pi2,2) + pow(pr1 - pr2,2)) - (pow(pi1,2) + pow(pr1 - pr2,2))*pr2 + pow(pi2,2)*(-2*pr1 + 3*pr2))))))*sin(pi2*t))/
	     (exp(pr2*t)*pi2*(pow(pi1,4) - 2*pow(pi1,2)*(pow(pi2,2) - pow(pr1 - pr2,2)) + pow(pow(pi2,2) + pow(pr1 - pr2,2),2))*(pow(k4,2) + pow(pi2,2) - 2*k4*pr2 + pow(pr2,2))*(pow(k6,2) + pow(pi2,2) - 2*k6*pr2 + pow(pr2,2))*
       (pow(p0,2) + pow(pi2,2) - 2*p0*pr2 + pow(pr2,2))));


  if (t > 0)
    return value;
  else
    return 0;
}



double response_legacy(double *x, double *par){
  Double_t t = x[0]-par[0];
  Double_t A0 = par[1];
  Double_t tp = par[2];

  Double_t reltime = t / tp;
  Double_t gain = A0* 1.012;

  Double_t value = 4.31054 * exp(-2.94809 * reltime) * gain - 2.6202 * exp(-2.82833 * reltime) * cos(1.19361 * reltime) * gain -
           2.6202 * exp(-2.82833 * reltime) * cos(1.19361 * reltime) * cos(2.38722 * reltime) * gain +
           0.464924 * exp(-2.40318 * reltime) * cos(2.5928 * reltime) * gain +
           0.464924 * exp(-2.40318 * reltime) * cos(2.5928 * reltime) * cos(5.18561 * reltime) * gain +
           0.762456 * exp(-2.82833 * reltime) * sin(1.19361 * reltime) * gain -
           0.762456 * exp(-2.82833 * reltime) * cos(2.38722 * reltime) * sin(1.19361 * reltime) * gain +
           0.762456 * exp(-2.82833 * reltime) * cos(1.19361 * reltime) * sin(2.38722 * reltime) * gain -
           2.620200 * exp(-2.82833 * reltime) * sin(1.19361 * reltime) * sin(2.38722 * reltime) * gain -
           0.327684 * exp(-2.40318 * reltime) * sin(2.5928 * reltime) * gain +
           +0.327684 * exp(-2.40318 * reltime) * cos(5.18561 * reltime) * sin(2.5928 * reltime) * gain -
           0.327684 * exp(-2.40318 * reltime) * cos(2.5928 * reltime) * sin(5.18561 * reltime) * gain +
           0.464924 * exp(-2.40318 * reltime) * sin(2.5928 * reltime) * sin(5.18561 * reltime) * gain;


  if (t > 0 and t<10)
    return value;
  else
    return 0;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////



void PlotandFitWaveforms(int run) {

   cout << "----------> Running fits for run number: " << run << endl;

   // Open the ROOT file to READ our averaged histograms (no average for now)
   //TFile *inputFile = new TFile(Form("/home/karla/Documents/WireCell/calibration/hd/simple_fitter/averaging/average_waveforms/averaged_waveforms_run_%d_HD.root", run), "READ");

   // Open the ROOT file to read the data
    TFile *inputFile = new TFile(Form("/home/karla/Documents/WireCell/wf_root/magnify-%d-8.root", run), "READ");



   //////////// Declaring variables for TRee Branches ////////////////////////


   int fitStatus;
   int iFit = 0;

   double prefit_chi2DOF;
   double prefit_param[7];
   double prefit_paramError[7];
   double prefit_chi2;
   double prefit_dof;

   double chi2DOF;
   double param[7];
   double paramError[7];
   double chi2;
   double dof;
   double covarianceMatrix[7][7];

   std::vector<double> fittedValues; // Vector to store the evaluated fit function

   TH1F* h_averaged_ptr = nullptr; // Pointer to the averaged waveform histogram.

   // Create ROOT file to store the tree
   TFile *outputFile = new TFile(Form("data_files/root/fit_results_run_%d_no_avg.root",run), "RECREATE");
   TTree *fitTree = new TTree("FitResults", "Fit Results Tree");

   // Link branches to the variables
   fitTree->Branch("iFit", &iFit, "iFit/I");
   fitTree->Branch("fitStatus", &fitStatus, "fitStatus/I");

   fitTree->Branch("prefit_chi2DOF", &prefit_chi2DOF, "prefit_chi2DOF/D");
   fitTree->Branch("prefit_param", prefit_param, "prefit_param[7]/D");
   fitTree->Branch("prefit_paramError", prefit_paramError, "prefit_paramError[7]/D");
   fitTree->Branch("prefit_chi2", &prefit_chi2, "prefit_chi2/D");
   fitTree->Branch("prefit_dof", &prefit_dof, "prefit_dof/D");


   fitTree->Branch("chi2DOF", &chi2DOF, "chi2DOF/D");
   fitTree->Branch("param", param, "param[7]/D");
   fitTree->Branch("paramError", paramError, "paramError[7]/D");
   fitTree->Branch("chi2", &chi2, "chi2/D");
   fitTree->Branch("dof", &dof, "dof/D");
   fitTree->Branch("covMatrix", covarianceMatrix, "covMatrix[7][7]/D");

   fitTree->Branch("f_response", &fittedValues);
   fitTree->Branch("h_peaks", &h_averaged_ptr);


   ///////////////////////////////////////////////////////////////////////////////////////////

   // Open ROOT file to save histograms:

   std::ofstream fit_results_file("data_files/txt/fit_results_run_" + std::to_string(run) + "_no_avg.txt");
   fit_results_file << "#Ch. # \t t \t E(t) \t A_0 \t E(A_0) \t t_p \t E(t_p) \t k3 \t E(k3) \t k4 \t E(k4) \t k5 \t E(k5) \t k6 \t E(k6) \t Chi2/DOF" << endl;

   std::ofstream pre_fit_results_file("data_files/txt/pre_fit_results_run_" + std::to_string(run) + "_no_avg.txt");
   pre_fit_results_file << "#Ch. # \t t \t E(t) \t A_0 \t E(A_0) \t t_p \t E(t_p) \t Chi2/DOF" << endl;

   std::ofstream failed_fits_file("data_files/txt/failed_fits_run_" + std::to_string(run) + "_no_avg.txt");



   // Retrieve the TH2I histogram
    TH2I *hist2D = (TH2I*)inputFile->Get("h_daq");
    if (!hist2D) {
        std::cerr << "Histogram not found!" << std::endl;
        return;
    }



    // Specify the bins we are interested in
    std::vector<int> selectedChannels = {6766,6767,6768,6769,6770};


    //for(int i : selectedChannels){
    for(int i = 1; i <= hist2D->GetNbinsX() ; ++i) {
    //for(int i = 1; i <= 10 ; ++i) {

       // Getting rid of dead channels:
      if(i == 7877 || i== 9121 || i== 9126 || i== 9127 || i== 9128 || i== 9307 || i== 9308 || i== 9310 || i== 9311 || i== 9535){

         fit_results_file << i-1 << "\t"
         << 5.0 << "\t" << 0 << "\t"
         << 75000 << "\t" << 0 << "\t"
         << 2.2 << "\t" << 0 << "\t"
         << 0.1 << "\t" << 0 << "\t"
         << 0.1 << "\t" << 0 << "\t"
         << 0.0 << "\t" << 0 << "\t"
         << 0.0 << "\t" << 0 << "\t"
         << 1 <<  endl;

         iFit = i-1;

         continue;
      }

      cout << "\n\n********* Ch. " << (i-1) << " *********\n" << endl;

      //Retrieve the histogram:
      //TH1D *h_averaged = (TH1D*)inputFile->Get(Form("h_averaged_ch_%d", i-1));


      // Generate projY histogram name
      TString projYName = TString::Format("projY_ch_%d", (i-1));
      TH1D *projY = hist2D->ProjectionY(projYName, i, i);
      //std::cout << "Number of Bins in ProjY(h_daq):  " << projY->GetNbinsX() << endl;

      // Getting the max and min values of the histogram to use as thresholds:
      double max = projY->GetMaximum();
      double min = projY->GetMinimum();

      //cout << "Maximum Amplitude: " << max << endl;
      //cout << "Minimum Amplitude: " << min << endl;


      // Giving a nice format to plots in case we want to plot raws:
      projY->SetStats(kFALSE);
      projY->GetXaxis()->SetTitle("Ticks");
      projY->GetYaxis()->SetTitle("ADC counts");
      projY->GetYaxis()->SetRangeUser(-9000, 9000);
      //projY->GetXaxis()->SetRangeUser(5500, 6000);
      projY->SetLineWidth(1);
      projY->SetLineColor(kBlue);
      projY->GetYaxis()->SetLabelSize(0.025);
      projY->GetYaxis()->SetTitleSize(0.03);
      projY->Draw();
      //gPad -> Print(Form("plots/raws/WF_Raw_Ch_%i_Run_%i_HD.png",(i-1),run));


      // Finding ALL peaks for each histogram:
      double positiveThreshold = max/2.0; // is this the best option for threshold?
      double negativeThreshold = min/2.0;

      std::vector<int> positivePeakBins; //An array with Positive Peak positions
      std::vector<double> positivePeakValues;
      std::vector<int> negativePeakBins; // An array with Negative Peak positions
      std::vector<double> negativePeakValues;

      // Find peaks:
      bool wasProcessed = FindPeaksWithNoiseCheck(projY, positiveThreshold, negativeThreshold, positivePeakBins, positivePeakValues, negativePeakBins, negativePeakValues, 1000000); //1000000 entries is taken as a noisy histogram here.

      if(wasProcessed==0) continue; // If noisy, skip.

      //---------------------------------------------------------
      // Dealing with waveforms starting too close to zero:
      if(positivePeakBins.size()>1 && positivePeakBins[0]< 100){

         // Shift all elements to the left
         for (size_t i = 1; i < positivePeakBins.size(); ++i) {
               positivePeakBins[i-1] = positivePeakBins[i];
         }

         for (size_t i = 1; i < positivePeakValues.size(); ++i) positivePeakValues[i-1] = positivePeakValues[i];


         // Resize the vectors to remove the last element (since it's now a duplicate)
         positivePeakBins.resize(positivePeakBins.size() - 1);
         positivePeakValues.resize(positivePeakValues.size() - 1);

         cout << "First POSITIVE peak was discarded. New peaks are at:\n " << endl;
         for (size_t i = 0; i < positivePeakBins.size(); ++i) {
               std::cout << "Bin: " << positivePeakBins[i] << ", Value: " << positivePeakValues[i] << "\n";
         }

      }


      //---------------------------------------------------------

      // Dealing with special cases when finding peaks:

      if (positivePeakBins.size()<= 0) cout << "**************** WARNING: No peaks were found! *******" << endl;

      if (positivePeakBins.size()== 1) cout << "**************** WARNING: Only one peak found! *******" << endl;

      // If the last peak is "incomplete" (non-bipolar)/ This definition probably needs more work.
      // Spacing between positive peak and negative peak is about 269 ticks
      if( positivePeakBins.size()>1 && positivePeakBins[positivePeakBins.size() -1] > 5750 ){

         // Resize the vectors to remove the last element (since it's now useless)
         positivePeakBins.resize(positivePeakBins.size() - 1);
         positivePeakValues.resize(positivePeakValues.size() - 1);

         cout << "Last POSITIVE peak was discarded. New peaks are at:\n " << endl;
         for (size_t i = 0; i < positivePeakBins.size(); ++i) {
               std::cout << "Bin: " << positivePeakBins[i] << ", Value: " << positivePeakValues[i] << "\n";
         }

      }
      //---------------------------------------------------------

      // Creating an array of histograms to store our peaks for each channel:
      std::vector<TH1F*> h_peaks;

      int nbefore = 15; // Number of samples before positive peak
      int nafter = 100; // Number of samples after positive peak

      double x_min; // This would be tick0
      double x_max;
      double binLow;
      double binHigh;
      int nBins;


      for(int j=0; j<positivePeakBins.size(); ++j){ // For each peak, save a histogram

         if(positivePeakBins.size() == 1){ // If there is just one peak

               x_min = positivePeakBins[0]- nbefore;
               x_max = positivePeakBins[0] + nafter;

         }else{

               x_min = positivePeakBins[j]- nbefore;
               x_max = positivePeakBins[j] + nafter;

         }

         binLow = projY->FindBin(x_min);
         binHigh = projY->FindBin(x_max);

         // NUmber of bins  in our individual waveforms/peaks:
         nBins = abs(x_max - x_min + 1);
         if (nBins==0) nBins = abs(binHigh - binLow + 1);

         // Creating an array of histograms to store our peaks:
         h_peaks.push_back(new TH1F(Form("hist_%d_channel_%i", j, i-1), Form("Pulse %i, Channel %i", j, i-1), nBins, 0, nBins));

         // Filling up individual pulse histograms:

         int newBinZero = 0;

         for(int k = binLow; k <= binHigh; ++k){

            newBinZero = newBinZero + 1;

            double binContent = projY->GetBinContent(k); // Get the number of entries in the bin
            h_peaks[j]->SetBinContent(newBinZero, binContent);

         }


         // Plot individual peaks:
         ScaleXaxis(h_peaks[j], ScaleX);
         h_peaks[j]->GetXaxis()->SetRangeUser(0,70);

         h_peaks[j]->SetLineColor(kBlue);
         h_peaks[j]->GetXaxis()->SetTitle("Ticks");
         h_peaks[j]->GetYaxis()->SetTitle("ADC counts");
         h_peaks[j]->SetLineWidth(1);
         h_peaks[j]->SetLineColor(4);
         h_peaks[j]->GetYaxis()->SetLabelSize(0.025);
         h_peaks[j]->GetYaxis()->SetTitleSize(0.03);
//          h_peaks[j]->Draw("HIST");
         h_peaks[j]->SetMarkerStyle(20);
         h_peaks[j]->Draw("P");
         //gPad -> Print(Form("plots/non-fitted/Ch_%i_WF_%i_Run_%i_HD.png",(i-1),j,run));


      } // After this FOR, individual pulse histograms have been created and stored in h_peaks[j].


      // To use when saving the histogram in the ROOT tree
      h_averaged_ptr = h_peaks[0]; // WARNING: CAREFUL WHEN USING IN PLOTTING SCRIPTS!



      /////////////////////////////////////////////////////////////////////////////////
      // FITTING THE WAVEFORMS:
      /////////////////////////////////////////////////////////////////////////////////


      ROOT::Math::MinimizerOptions::SetDefaultMaxFunctionCalls(100000);

      // Pre fitting: Using old electronics response provided by Wenqiang.
      TF1 *f_ideal = new TF1("f_ideal", response_legacy, 0,100,3);
        f_ideal->SetNpx(1000);

      // Fitting using response provided by Xin:
      TF1 *f_response = new TF1("f_response", response, 0,100,7);
        //(t, A0, tp, k3, k4, k5, k6)
        //t = x[0] - par[0], A0 = par[1], tp = par[2].
      f_response->SetNpx(1000);

      TF1* bestFitFunc;
      TFitResultPtr bestFit;


      f_ideal -> SetParameters(5.0, max, 2.2);
        // Gaussian, using old electronics response (t,A0,t_p).
      TFitResultPtr r0 =  h_peaks[0] -> Fit("f_ideal","QS","",0,10.0);

      double chi2_0 = r0->Chi2();
      double dof_0 = r0->Ndf();
      double chi2PerDof_0 = dof_0 > 0 ? chi2_0 / dof_0 : 0; // Avoid division by zero

      //saving values in ROOT tree:
      prefit_chi2 = chi2_0;
      prefit_dof = dof_0;


      // Writing pre-fit results in a file to plot them later:
       pre_fit_results_file << i-1 << "\t"
       << setprecision(10) << r0->Parameter(0) << "\t" << setprecision(10) << r0->Error(0) << "\t"
       << setprecision(10) << r0->Parameter(1) << "\t" << setprecision(10) << r0->Error(1)  << "\t"
       << setprecision(10) << r0->Parameter(2) << "\t" << setprecision(10) << r0->Error(2) << "\t"
       << setprecision(10) << chi2PerDof_0 << endl;

      // If there are channels with zero tails:
       if (min == 0)  failed_fits_file << i-1 << "\t (zero baseline)" << endl;


      // Loop over parameters to store them in arrays
      for (int j = 0; j < 7; j++) {
         prefit_param[j] = r0->Parameter(j);
         prefit_paramError[j] = r0->Error(j);
      }

      // Storing chi2/DOF
      prefit_chi2DOF = chi2PerDof_0;

      if(chi2_0 >= 10000){// Completely arbitrary
         failed_fits_file << i-1 << "\t High PreFit Chi2: \t" << chi2_0 << endl;

      }


      //Feed pre-fit parameters to response function:
      f_response->SetParameters(f_ideal->GetParameter(0),f_ideal->GetParameter(1),f_ideal->GetParameter(2), 0.2, 0.25,0.03,0.03);
            // simple 1: 0.1,0.1,0.03,0.03
            // simple 2: 0.15,0.2,0.03,0.03
            // simple 3: 0.2, 0.25,0.03,0.03 // Using this one for all!
            //(t, A0, tp, k3, k4, k5, k6)

      // Setting some parameter limits for the amplitude:
      f_response->SetParLimits(1,f_ideal->GetParameter(1)*0.8,f_ideal->GetParameter(1)*1.2);

      //f_response->Draw("same");
      //gPad->Print(Form("7.8_gain/plots/fitted_waveforms/30DAC/double_fit/Fitted_Ch_%i_Run_%i_HD_AVG.png",(i-1),run));

      f_response->FixParameter(0, f_ideal->GetParameter(0));
      f_response->FixParameter(1, f_ideal->GetParameter(1));
      f_response->FixParameter(2, f_ideal->GetParameter(2));


      TFitResultPtr r = h_peaks[0]->Fit(f_response,"RS","",0,50.0);
      double chi2 = r->Chi2();
      double dof = r->Ndf();
      double chi2PerDof = dof > 0 ? chi2 / dof : 0;


      f_response->ReleaseParameter(0);
      f_response->ReleaseParameter(1);
      f_response->ReleaseParameter(2);


      f_response -> SetParName(0,"t");
      f_response -> SetParName(1,"A_{0}");
      f_response -> SetParName(2,"t_{p}");
      f_response -> SetParName(3,"k_{3}");
      f_response -> SetParName(4,"k_{4}");
      f_response -> SetParName(5,"k_{5}");
      f_response -> SetParName(6,"k_{6}");

      f_response->SetParLimits(1,r->Parameter(1)*0.8,r->Parameter(1)*1.2);

      TFitResultPtr r2 = h_peaks[0]->Fit(f_response,"RS","",0,50.0);

      double chi22 = r2->Chi2();
      double dof2 = r2->Ndf();
      double chi2PerDof2 = dof2 > 0 ? chi22 / dof2 : 0;

      //saving in ROOT tree:
      chi2 = chi22;
      dof = dof2;

      bestFit = r2;
      bestFitFunc = f_response;

//       h_peaks[0]->GetXaxis()->SetRangeUser(5,15);
//       h_peaks[0]->SetMarkerStyle(20);
//       h_peaks[0]->Draw("P");
//       bestFitFunc->Draw("same");
//       gPad->Print(Form("plots/fitted/Fitted_Ch_%d_Run_%d.png",(i-1),run));


      if(chi22 >= 10000) {// Completely arbitrary number, used to define failed fits.
         failed_fits_file << i-1 << "\t High Fit Chi2: \t" << chi22 << endl;

      }


//       // Saving fit results into a file:
       fit_results_file << i-1 << "\t"
         << setprecision(10) << r2->Parameter(0) << "\t" << setprecision(10) << r2->Error(0) << "\t"
         << setprecision(10) << r2->Parameter(1) << "\t" << setprecision(10) << r2->Error(1) << "\t"
         << setprecision(10) << r2->Parameter(2) << "\t" << setprecision(10) << r2->Error(2) << "\t"
         << setprecision(10) << r2->Parameter(3) << "\t" << setprecision(10) << r2->Error(3) << "\t"
         << setprecision(10) << r2->Parameter(4) << "\t" << setprecision(10) << r2->Error(4) << "\t"
         << setprecision(10) << r2->Parameter(5) << "\t" << setprecision(10) << r2->Error(5) << "\t"
         << setprecision(10) << r2->Parameter(6) << "\t" << setprecision(10) << r2->Error(6) << "\t"
         << setprecision(10) << chi2PerDof2 <<  endl;


      // Loop over parameters to store them in our arrrays
      for (int j = 0; j < 7; j++) {
         param[j] = r2->Parameter(j);
         paramError[j] = r2->Error(j);
      }

      chi2DOF = chi2PerDof2;


      // Retrieve and store the covariance matrix (7x7)
      for (int row = 0; row < 7; row++) {
         for (int col = 0; col < 7; col++) {
               covarianceMatrix[row][col] = r2->CovMatrix(row, col);  // Covariance matrix element
         }
      }


      // Fit status:
      int fit_Status = r2->Status();
      fitStatus = fit_Status;

      // Save channel in Tree:
      iFit = i-1;

      // Storing the evaluated response function with the fit parameters:
      fittedValues.clear();

      for (int bin = 1; bin <= h_peaks[0]->GetNbinsX(); ++bin) {

         double x = h_peaks[0]->GetBinCenter(bin);
         double y_fitted = bestFitFunc->Eval(x);  // Evaluate fit function at bin center
         fittedValues.push_back(y_fitted);        // Store the y-value
      }



      // Fill the tree with the current fit data
      fitTree->Fill();

      std::cout << "Fit Status: " << fit_Status << std::endl;
//
//       // Fit status interpretation:
//       // 0: Success (OK)
//       // 1: Covariance matrix was made positive definite
//       // 2: Hesse failed
//       // 3: Edm is above the maximum value
//       // 4: Reached maximum number of function calls
//       // 5: Fit failed
//
      if(fit_Status != 0) {
         failed_fits_file << i-1 << "\t" << fit_Status << endl;

      }


        // Clean up functions and hists
         delete f_response;
         delete f_ideal;
         //delete h_averaged;
         for (size_t i = 0; i < h_peaks.size(); ++i) delete h_peaks[i];


    } //END FOR Channels



    fitTree->Write();    // Write the tree to the output file
    outputFile->Close();

    // Clean up and close files
    inputFile->Close();

    pre_fit_results_file.close();
    fit_results_file.close();
    failed_fits_file.close();


} // END OF FITTER Function


////////////////////////////////////////////////////////////////////////////////


void wf_fitter_2_HD_NO_AVG(int run) {

    PlotandFitWaveforms(run);
}





